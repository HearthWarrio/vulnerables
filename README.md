**Уязвимое микросервисное веб-приложение**

**1. Архитектура приложения**

Приложение строится по микросервисной архитектуре: каждый сервис отвечает за демонстрацию одной определенной уязвимости на стороне сервера. Все сервисы развернуты независимо (каждый в своем Docker-контейнере) и взаимодействуют через легковесные HTTP API. Это обеспечивает модульность — уязвимости изолированы друг от друга, и каждый микросервис можно запускать/тестировать отдельно. Во варианте на Python каждый микросервис реализован с использованием веб-фреймворка (Flask или FastAPI) и запускается, например, на отдельном порту. Во варианте на Java используются Spring Boot + Hibernate для реализации сервисов, также запускающихся отдельно. В обоих случаях микросервисы обмениваются данными посредством REST API (формат JSON) по HTTP. Общая схема: клиент (тестер) обращается к нужному endpoint-у определенного микросервиса (напрямую или через общий API-шлюз). Docker Compose используется для оркестрации: он поднимает сеть, в которой все контейнеры (сервисы) доступны друг другу по именам. Это позволит демонстрировать, например, SSRF-вектор, когда один сервис может отправлять запросы к другому по внутреннему адресу. Также в составе может присутствовать простой API Gateway (или прокси) для маршрутизации запросов по различным сервисам, хотя для простоты можно и без него — обращаясь к сервисам по разным портам. Каждый микросервис может иметь свою небольшую базу данных или хранилище, если нужно (для Python можно использовать SQLite, для Java — встраиваемую H2 или PostgreSQL в контейнере). Однако для большинства уязвимостей (кроме, например, IDOR) можно обойтись без полноценной БД, храня данные в памяти или файлах для упрощения. Все конфигурации (например, порты, пути к файлам) задаются через переменные окружения в docker-compose, чтобы было удобно настраивать тестовое окружение. Итогом архитектуры является набор независимых сервисов, каждый из которых демонстрирует определенную уязвимость, но при этом они могут взаимодействовать. Такое разделение облегчает понимание каждой уязвимости в отдельности и соответствует принципам микросервисов (каждый выполняет одну функцию). Ниже перечислены микросервисы и их предназначение.

**2. Состав микросервисов и их назначение**

Каждая из следующих уязвимостей реализована как отдельный сервис или по крайней мере отдельный endpoint в составе микросервиса. Для наглядности лучше выделить по отдельному микросервису под каждую уязвимость:
File Upload Service (уязвимость: небезопасная загрузка файлов) – Позволяет загружать файлы на сервер без надлежащей проверки. Демонстрирует угрозы, связанные с отсутствием валидации типа/размера файла, возможностью загрузить исполняемый или вредоносный файл, а также атак типа Path Traversal при некорректной обработке имени файла.
IDOR Service (Insecure Direct Object Reference, небезопасное прямое обращение к объекту) – Предоставляет доступ к объектам (записям) по их идентификаторам без проверки прав доступа. Этот сервис имитирует ситуацию, когда пользователь может запросить данные по ID, который ему не принадлежит, из-за отсутствия проверки авторизации.
SSRF Service (Server-Side Request Forgery, подделка серверного запроса) – Принимает от пользователя URL и серверный сервис осуществляет запрос по этому URL. Демонстрирует, как злоумышленник может заставить сервер сделать запрос к внутреннему ресурсу (например, другому микросервису или внешнему адресу), который напрямую из внешней сети недоступен.
XXE Service (XML External Entity, уязвимость обработки внешних XML-энтити) – Принимает XML-документ от пользователя и парсит его небезопасно. Показывает, как через специально сформированный XML с внешними сущностями злоумышленник может получить доступ к файлам на сервере или выполнить запросы от имени сервера.
SSTI Service (Server-Side Template Injection, инъекция в шаблон) – Демонстрирует уязвимость шаблонизации на стороне сервера. Сервис генерирует контент на основе шаблона, в который попадают непроверенные пользовательские данные. Это позволяет выполнить произвольные выражения или даже код на сервере через механизм шаблонизатора.
LFI Service (Local File Inclusion, локальное включение файлов) – Позволяет клиенту запросить локальный файл по имени/пути. Этот сервис умышленно не проверяет путь, поэтому его можно эксплуатировать для чтения произвольных файлов на сервере (например, "../../etc/passwd").
RFI Service (Remote File Inclusion, удалённое включение файлов) – Позволяет включить и выполнить удаленный файл, адрес которого передается пользователем. В веб-контексте RFI означает, что приложение может загружать код или данные с внешнего ресурса и исполнять их локально. Сервис демонстрирует опасность такой функциональности, позволяя злоумышленнику выполнить свой код на сервере, предоставив ссылку на вредоносный скрипт.
Каждый микросервис содержит хотя бы один уязвимый endpoint (HTTP маршрут) реализующий описанную логику. Например, File Upload Service может иметь маршрут /upload для загрузки и /files/<name> для доступа к загруженному файлу; IDOR Service – маршрут вроде /api/records/<id>; SSRF Service – маршрут /fetch?url=... и т.д. Взаимодействие между сервисами: по умолчанию каждый обслуживает свою уязвимость в отрыве, но при желании можно демонстрировать комплексные атаки, где один уязвимый сервис используется для атаки на другой (например, SSRF вызывает внутренний адрес IDOR-сервиса). Ниже приводятся технические детали реализации каждого сервиса на Python и Java.
